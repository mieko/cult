#!/usr/bin/env ruby
$LOAD_PATH << File.expand_path(File.join(__dir__, '../lib'))

require 'cri'

require 'cult/version'
require 'cult/config'
require 'cult/project'
require 'cult/node'
require 'cult/cli/load'
require 'cult/drivers/load'

cult = Cri::Command.define do
  optional_project
  name        'cult'
  usage       'cult [options] [command [options...]]'
  summary     'Control a Fleet of Obedient Zomboid Machines'
  description <<~EOD
    Cult is a tool for creating and then managing a fleet of servers you
    control.  It operates on a few simple concepts:

      * Nodes: actual servers out there somewhere.  The purpose of using Cult is
        to end up with nodes doing useful work for you.

      * Roles: Every node has one or more roles, things it plans on being.
        Roles are composed of...

      * Tasks: Basically shell scripts that run in a specific order.

   Cult has a few more convenience concepts, like Keys and Providers, but you
   don't end up thinking about them too often.

   To create a new Cult project, use 'cult init DIRECTORY', but see the 'init'
   help first, with 'cult init --help'
  EOD

  required :C, :directory, 'Specify a project path' do |value|
    Cult::CLI.set_project(value)
  end

  flag :h, :help, 'Show this help' do |value, cmd|
    puts cmd.help
  end

  flag :y, :yes, 'Answer "yes" to any questions' do
    Cult::CLI.yes = true
  end

  flag :q, :quiet, "Don't show any unnecessary information" do
    Cult::CLI.quiet = true
  end

  flag :v, :version, 'Show version information' do
    puts "Cult #{Cult::VERSION}"
    puts 'Copyright (C) 2016 Mike A. Owens, meter.md, and Contributors'
  end

  run do |_, _, cmd|
    puts cmd.help
  end
end

Cult::CLI.commands.each do |m|
  cult.add_command(m)
end

if (env = ENV['CULT_PROJECT'])
  Cult::CLI.set_project(env)
else
  Cult.project ||= Cult::Project.from_cwd
end

if Cult.project
  cultrc = Cult.project.location_of(".cultrc")
  load(cultrc) if File.exist?(cultrc)
end

begin
  cult.run(ARGV)
rescue Cult::CLI::CLIError, RegexpError => e
  $stderr.puts "#{File.basename($0)}: #{e.message}"
  exit 1
rescue Interrupt
  exit 1
end
